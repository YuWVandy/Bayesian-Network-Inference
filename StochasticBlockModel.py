# -*- coding: utf-8 -*-
"""
Created on Mon Mar 23 09:52:20 2020

@author: 10624
"""

# -*- coding: utf-8 -*-
"""
Created on Sat Mar 21 00:15:24 2020

@author: 10624
"""
import networkx as nx
import numpy as np
from matplotlib import pyplot as plt

class SBM(object):
    def __init__(self, community_num, nodenum, edgeprob, failprob, color):
        self.c_num = community_num
        self.n_num = nodenum #a list of the node number of each community
        self.edge_prob = edgeprob #a matrix where ep[i, j] is the edge probability between block i and j
    
        self.n = np.sum(self.n_num)

        self.edge_fail_prob = failprob
        
        self.generate_sbm(color)
        
    def generate_sbm(self, color):
        """Generate the stochastic block model based on networkx package
        """
        self.graph = nx.generators.community.stochastic_block_model(self.n_num, self.edge_prob)
        
        self.adjlist_matrix()
        self.community_label(color)
        self.layout_node()
        self.edge_failure_matrix(self.edge_fail_prob)
        self.graph_probability()
    
    def graph_probability(self):
        """Calculate the probability of the graph generated by stochastic block model
        """
        self.graph_log_prob = 0
        for i in range(self.n):
            for j in range(i + 1, self.n):
                if(self.adj_matrix[i, j] == 1):
                    self.graph_log_prob += np.log(self.edge_prob[self.community[i]][self.community[j]])
                else:
                    self.graph_log_prob += np.log(1 - self.edge_prob[self.community[i]][self.community[j]])
                
    
    def adjlist_matrix(self):
        """Generate the adjacent matrix and list for the graph
        """
        self.adj_matrix = nx.to_numpy_matrix(self.graph)
        self.adj_list = nx.to_dict_of_lists(self.graph)
    
    def community_label(self, color):
        """Assign the community label to corresponding nodes
        """
        
        self.community = []
        self.color = []
        for i in range(len(self.n_num)):
            for j in range(self.n_num[i]):
                self.community.append(i)
                self.color.append(color[i])
    
    def layout_node(self):
        """Calculate the node position based on spring out method
        """
        self.node_pos = nx.spring_layout(self.graph)

    def edge_failure_matrix(self, probability):
        """Calculate the failure matrix of the whole graph based on given instructions
        Input: probability for stochastic block model
        Output: failure matrix of dimension n*n, fail_matrix[i, j] represents the failure probability of edge (i, j)
        """
        
        self.edge_fail_matrix = np.zeros([self.n, self.n])
        for i in range(self.n):
            for j in range(self.n):
                self.edge_fail_matrix[i, j] = probability[self.community[i], self.community[j]]
    
    def failure_probability(self):
        """Calculate the node failure probability based on failure_matrix
        Input: failure probability of each edge (conditional failure probability)
               failure_sequence: node failure sequence: 1 - failed, 2 - normal
        Output: failure_probability of each node
        """
        
        node_fail_prob = np.zeros(self.n)
        node_fail_sequence = self.node_fail_sequence[-1]
        
        for i in range(self.n):
            temp = 0
            for j in range(self.n):
                temp += self.adj_matrix[i, j]*np.log(1 - self.edge_fail_matrix[i, j])*node_fail_sequence[j]
            node_fail_prob[i] = 1 - np.exp(temp)
        
        self.node_fail_prob.append(node_fail_prob)
        
    def failure_sequence(self):
        """Simulate one further node failure sceneria based on MC simulation
        Input: the node failure sceneria at the previous step, the node_fail_probability at previous step
        Output: the node failure sceneria at the current step
        """
        node_fail_sequence = np.zeros(self.n)
        node_fail_prob = self.node_fail_prob[-1]
        
        for i in range(self.n):
            if(self.node_fail_sequence[-1][i] == 0):
                temp = np.random.rand()
                if(temp < node_fail_prob[i]):
                    node_fail_sequence[i] = 1
        
        self.node_fail_sequence.append(node_fail_sequence)
    
    def generate_initial_failure(self, num, seed):
        """Generate the initial node failure sceneria
        Input: the number of initial failure nodes
        output: the initial failure sequence
        """
        self.node_fail_prob = []
        self.node_fail_sequence = []
        self.node_fail_final = []
        
        
        initial_node_failure = np.zeros(self.n)
#       np.random.seed(seed)
        temp = np.random.randint(self.n, size = num)
        initial_node_failure[temp] = 1
        self.node_fail_sequence.append(initial_node_failure)
        self.node_fail_final.append(initial_node_failure)

    def failure_simulation(self):
        """Simulate the node failure sequence along the time
        Input: Initial node failure sceneria
        Output: Node failure sequence, node failure probability
        """
        
        while(1):
            self.failure_probability()
            self.failure_sequence()
            
            node_fail_final = np.zeros(self.n)
            for i in range(self.n):
                if(self.node_fail_final[-1][i] == 1 or self.node_fail_sequence[-1][i] == 1):
                    node_fail_final[i] = 1
            self.node_fail_final.append(node_fail_final)
            
            if((self.node_fail_final[-1] == self.node_fail_final[-2]).all() or (np.sum(self.node_fail_final[-1]) == self.n)):
                break    
        
    def draw_sbm(self):
        """Visualize the graph generated by stochastic block model based on spring out
        """
        
        plt.figure(figsize = (8, 8))
        plt.axis('off')
        nx.draw_networkx_nodes(self.graph, self.node_pos, node_size = 600, node_color = self.color)
        nx.draw_networkx_edges(self.graph, self.node_pos, alpha = 0.3)
        plt.show()
        
    def visual_failure_process(self, Color):
        """Visualize the failure process of the graph
        """
        import networkx as nx
        
        time_step = len(self.node_fail_final)
        for i in range(time_step):
            color = []
            sequence = self.node_fail_final[i]
            for j in range(self.n):
                if(sequence[j] == 0):
                    color.append(Color[self.community[j]][0])
                else:
                    color.append(Color[self.community[j]][1])
            
            plt.figure(figsize = (8, 8))
            plt.axis('off')
            nx.draw_networkx_nodes(self.graph, self.node_pos, node_size = 600, node_color = color,frameon=False)
            nx.draw_networkx_edges(self.graph, self.node_pos, alpha = 0.3,frameon=False)
        
color = ['maroon', 'navy', 'darkgreen']
probability = np.array([[0.2, 0.01, 0.02], [0.02, 0.3, 0.04], [0.01, 0.03, 0.1]])
A = SBM(3, [30, 20, 10], [[0.7, 0.1, 0.2], [0.1, 0.6, 0.15], [0.2, 0.15, 0.7]], probability, color)
A.draw_sbm()
A.generate_initial_failure(8, 1)
A.failure_simulation()
color2 = [['maroon', 'orange'], ['navy', 'lightskyblue'], ['darkgreen', 'mediumspringgreen']]
A.visual_failure_process(color2)
